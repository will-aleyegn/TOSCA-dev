# VmbPy Basic Usage Guide

This guide provides simple instructions for common camera operations using the VmbPy API for Allied Vision cameras.

## 1. Setup and Camera Connection

```python
import vmbpy

# Connect to the camera system
with vmbpy.VmbSystem.get_instance() as vmb:
    # List all cameras
    cameras = vmb.get_all_cameras()
    print(f"Found {len(cameras)} cameras")
    
    if cameras:
        # Connect to the first camera
        with cameras[0] as cam:
            # Get camera information
            print(f"Using camera: {cam.get_name()} ({cam.get_id()})")
            print(f"Model: {cam.get_model()}")
            print(f"Serial: {cam.get_serial()}")
            
            # Camera operations go here
```

## 2. Adjusting Basic Camera Settings

### 2.1 Setting Pixel Format

```python
# Set to color format
cam.set_pixel_format(vmbpy.PixelFormat.Bgr8)  # Good for OpenCV compatibility

# Or set to monochrome format
# cam.set_pixel_format(vmbpy.PixelFormat.Mono8)
```

### 2.2 Adjusting Exposure

```python
try:
    # Get exposure feature
    exposure_feature = cam.get_feature_by_name("ExposureTime")
    
    # Get exposure range
    min_exp, max_exp = exposure_feature.get_range()
    print(f"Exposure range: {min_exp} to {max_exp} μs")
    
    # Set exposure (in microseconds)
    exposure_feature.set(10000)  # 10 ms exposure
    print(f"Exposure set to {exposure_feature.get()} μs")
    
except vmbpy.VmbFeatureError as e:
    print(f"Exposure error: {e}")
```

### 2.3 Adjusting Gain

```python
try:
    # Get gain feature
    gain_feature = cam.get_feature_by_name("Gain")
    
    # Get gain range
    min_gain, max_gain = gain_feature.get_range()
    print(f"Gain range: {min_gain} to {max_gain}")
    
    # Set gain
    gain_feature.set(5.0)
    print(f"Gain set to {gain_feature.get()}")
    
except vmbpy.VmbFeatureError as e:
    print(f"Gain error: {e}")
```

### 2.4 Auto Exposure and Auto Gain

```python
# Setting Auto Exposure
try:
    auto_exposure = cam.get_feature_by_name("ExposureAuto")
    
    # Get available modes
    entries = auto_exposure.get_available_entries()
    print("Available exposure modes:", [entry.as_tuple()[0] for entry in entries])
    
    # Set to continuous auto exposure
    auto_exposure.set("Continuous")
    # Or turn off auto exposure
    # auto_exposure.set("Off")
    
except vmbpy.VmbFeatureError as e:
    print(f"Auto exposure error: {e}")

# Setting Auto Gain
try:
    auto_gain = cam.get_feature_by_name("GainAuto")
    
    # Set to continuous auto gain
    auto_gain.set("Continuous")
    # Or turn off auto gain
    # auto_gain.set("Off")
    
except vmbpy.VmbFeatureError as e:
    print(f"Auto gain error: {e}")
```

## 3. Acquiring Images

### 3.1 Capturing a Single Frame

```python
# Get a single frame with timeout of 2000ms
frame = cam.get_frame(timeout_ms=2000)

# Convert to numpy array for processing
import numpy as np
img = frame.as_numpy_ndarray()

# Display with OpenCV
import cv2
cv2.imshow("Camera Frame", img)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Save to file
cv2.imwrite("captured_image.png", img)
```

### 3.2 Capturing Multiple Frames

```python
# Capture 10 frames
for i, frame in enumerate(cam.get_frame_generator(limit=10)):
    # Convert to numpy array
    img = frame.as_numpy_ndarray()
    
    # Process the frame
    # ...
    
    # Save to file
    cv2.imwrite(f"frame_{i:03d}.png", img)
    
    # Display (press ESC to exit early)
    cv2.imshow("Frame", img)
    if cv2.waitKey(100) == 27:  # ESC key
        break

cv2.destroyAllWindows()
```

## 4. Streaming Video

### 4.1 Basic Frame Streaming

```python
def frame_handler(cam, stream, frame):
    """Handler called for each frame during streaming"""
    try:
        # Convert to numpy array
        img = frame.as_opencv_image()
        
        # Display the frame
        cv2.imshow("Live Stream", img)
        
        # Exit if ESC key is pressed
        key = cv2.waitKey(1)
        if key == 27:  # ESC key
            # Note: This won't actually stop streaming - 
            # need to handle this externally
            pass
        
        # Important: Queue the frame back for reuse
        cam.queue_frame(frame)
        
    except Exception as e:
        print(f"Error in frame handler: {e}")
        # Try to queue frame back even if error occurred
        try:
            cam.queue_frame(frame)
        except:
            pass

# Start streaming with 5 buffers
cam.start_streaming(frame_handler, buffer_count=5)

# Let the stream run for a while
import time
try:
    print("Streaming for 30 seconds (press ESC in window to exit early)...")
    time.sleep(30)
except KeyboardInterrupt:
    print("Streaming interrupted")

# Stop streaming
cam.stop_streaming()
cv2.destroyAllWindows()
```

### 4.2 Recording Video to File

```python
import cv2
import time

def record_video(camera, filename, duration=10, fps=30.0, codec='XVID'):
    """Record video from camera to file"""
    # Set up video writer
    frame = camera.get_frame()
    width = frame.get_width()
    height = frame.get_height()
    
    # Convert codec string to FourCC code
    fourcc = cv2.VideoWriter_fourcc(*codec)
    
    # Create video writer
    writer = cv2.VideoWriter(
        filename, 
        fourcc, 
        fps,
        (width, height)
    )
    
    if not writer.isOpened():
        print("Error: Could not open video writer")
        return
    
    # Set up recording variables
    start_time = time.time()
    frame_count = 0
    
    def frame_handler(cam, stream, frame):
        nonlocal frame_count
        
        try:
            # Convert to OpenCV format
            img = frame.as_opencv_image()
            
            # Write frame to video
            writer.write(img)
            frame_count += 1
            
            # Display preview
            cv2.imshow("Recording", img)
            cv2.waitKey(1)
            
            # Queue frame back
            cam.queue_frame(frame)
            
        except Exception as e:
            print(f"Error in recording: {e}")
            try:
                cam.queue_frame(frame)
            except:
                pass
    
    # Start streaming
    camera.start_streaming(frame_handler)
    
    # Record for specified duration
    try:
        while time.time() - start_time < duration:
            # Show progress
            elapsed = time.time() - start_time
            print(f"\rRecording: {elapsed:.1f}/{duration} seconds - {frame_count} frames", end="")
            time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nRecording interrupted")
    
    # Clean up
    print("\nStopping recording...")
    camera.stop_streaming()
    writer.release()
    cv2.destroyAllWindows()
    
    # Calculate actual FPS
    actual_duration = time.time() - start_time
    actual_fps = frame_count / actual_duration
    
    print(f"Recording complete: {filename}")
    print(f"Duration: {actual_duration:.1f} seconds")
    print(f"Frames: {frame_count}")
    print(f"Actual FPS: {actual_fps:.1f}")

# Usage example
record_video(cam, "camera_recording.avi", duration=10, fps=30.0)
```

## 5. Saving and Loading Camera Settings

### 5.1 Saving Camera Settings to XML

```python
# Configure your camera features
cam.get_feature_by_name("ExposureTime").set(10000)
cam.get_feature_by_name("Gain").set(5.0)

# Save all settings to XML file
cam.save_settings("camera_settings.xml")
print("Camera settings saved to camera_settings.xml")
```

### 5.2 Loading Camera Settings from XML

```python
# Load settings from previously saved XML file
cam.load_settings("camera_settings.xml")
print("Camera settings loaded from camera_settings.xml")

# Verify settings
exp = cam.get_feature_by_name("ExposureTime").get()
gain = cam.get_feature_by_name("Gain").get()
print(f"Loaded settings - Exposure: {exp} μs, Gain: {gain}")
```

## 6. Complete Example: Adjusting Settings and Recording Video

```python
import vmbpy
import cv2
import time
import os

def main():
    try:
        with vmbpy.VmbSystem.get_instance() as vmb:
            # Get the first available camera
            cameras = vmb.get_all_cameras()
            if not cameras:
                print("No cameras found!")
                return
            
            print(f"Found {len(cameras)} cameras. Using the first one.")
            
            with cameras[0] as cam:
                print(f"Camera: {cam.get_model()} ({cam.get_id()})")
                
                # Configure camera for recording
                try:
                    # Set pixel format to BGR for color video
                    cam.set_pixel_format(vmbpy.PixelFormat.Bgr8)
                    
                    # Turn off auto exposure and set manual exposure
                    cam.get_feature_by_name("ExposureAuto").set("Off")
                    cam.get_feature_by_name("ExposureTime").set(20000)  # 20ms
                    
                    # Turn off auto gain and set manual gain
                    cam.get_feature_by_name("GainAuto").set("Off")
                    cam.get_feature_by_name("Gain").set(10.0)
                    
                    # Save these settings
                    cam.save_settings("manual_settings.xml")
                    print("Manual settings saved to manual_settings.xml")
                    
                    # Record video with these settings
                    print("Recording video with manual settings...")
                    record_video(cam, "manual_settings.avi", duration=5)
                    
                    # Switch to auto settings
                    cam.get_feature_by_name("ExposureAuto").set("Continuous")
                    cam.get_feature_by_name("GainAuto").set("Continuous")
                    
                    # Save auto settings
                    cam.save_settings("auto_settings.xml")
                    print("Auto settings saved to auto_settings.xml")
                    
                    # Record with auto settings
                    print("Recording video with auto settings...")
                    record_video(cam, "auto_settings.avi", duration=5)
                    
                    # Test loading settings
                    print("Loading back manual settings...")
                    cam.load_settings("manual_settings.xml")
                    
                    # Verify settings were loaded
                    exp_mode = cam.get_feature_by_name("ExposureAuto").get()
                    exposure = cam.get_feature_by_name("ExposureTime").get()
                    gain_mode = cam.get_feature_by_name("GainAuto").get()
                    gain = cam.get_feature_by_name("Gain").get()
                    
                    print(f"Loaded settings:")
                    print(f"- Exposure Mode: {exp_mode}")
                    print(f"- Exposure Time: {exposure} μs")
                    print(f"- Gain Mode: {gain_mode}")
                    print(f"- Gain: {gain}")
                    
                except vmbpy.VmbFeatureError as e:
                    print(f"Feature error: {e}")
                    
    except vmbpy.VmbSystemError as e:
        print(f"VmbSystem error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")
        
def record_video(camera, filename, duration=10, fps=30.0, codec='XVID'):
    """Record video from camera to file"""
    # Get a frame to determine dimensions
    frame = camera.get_frame()
    width = frame.get_width()
    height = frame.get_height()
    
    # Create video writer
    fourcc = cv2.VideoWriter_fourcc(*codec)
    writer = cv2.VideoWriter(filename, fourcc, fps, (width, height))
    
    # Recording variables
    start_time = time.time()
    frame_count = 0
    
    def frame_handler(cam, stream, frame):
        nonlocal frame_count
        img = frame.as_opencv_image()
        writer.write(img)
        frame_count += 1
        cv2.imshow("Recording", img)
        cv2.waitKey(1)
        cam.queue_frame(frame)
    
    # Start streaming
    camera.start_streaming(frame_handler)
    
    # Record for specified duration
    try:
        while time.time() - start_time < duration:
            elapsed = time.time() - start_time
            print(f"\rRecording: {elapsed:.1f}/{duration} seconds", end="")
            time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nRecording interrupted")
    
    # Clean up
    print("\nFinishing recording...")
    camera.stop_streaming()
    writer.release()
    cv2.destroyAllWindows()
    
    actual_fps = frame_count / (time.time() - start_time)
    print(f"Recorded {frame_count} frames at {actual_fps:.1f} FPS")

if __name__ == "__main__":
    main()
```

## 7. Troubleshooting Common Issues

### Camera Not Found
- Check physical connections (USB, Ethernet)
- Ensure camera is powered on
- Verify camera is not being used by another application
- For GigE cameras, check network settings

### Feature Access Errors
- Ensure the feature exists on your camera model (features vary by model)
- Check feature interdependencies (e.g., must turn off auto exposure before setting exposure time)
- Verify camera access mode (some features require full access)

### Streaming Issues
- Always remember to queue frames back in streaming mode
- Increase buffer count for smoother streaming
- For network cameras, check bandwidth settings
- If streaming is unstable, try a different pixel format or resolution

### Frame Timeout Errors
- Increase timeout_ms parameter
- Check if camera is waiting for a trigger
- Verify camera is not in a fault state

This guide covers the basic functionality needed for most camera applications usi